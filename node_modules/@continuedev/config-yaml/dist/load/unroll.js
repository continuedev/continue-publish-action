import * as YAML from "yaml";
import { decodeFullSlug, encodePackageSlug, } from "../interfaces/slugs.js";
import { assistantUnrolledSchema, blockSchema, configYamlSchema, } from "../schemas/index.js";
export function parseConfigYaml(configYaml) {
    try {
        const parsed = YAML.parse(configYaml);
        const result = configYamlSchema.parse(parsed);
        return result;
    }
    catch (e) {
        console.log(configYaml);
        throw new Error(`Failed to parse rolled assistant: ${e.message}`);
    }
}
export function parseAssistantUnrolled(configYaml) {
    try {
        const parsed = YAML.parse(configYaml);
        const result = assistantUnrolledSchema.parse(parsed);
        return result;
    }
    catch (e) {
        throw new Error(`Failed to parse unrolled assistant: ${e.message}`);
    }
}
export function parseBlock(configYaml) {
    try {
        const parsed = YAML.parse(configYaml);
        const result = blockSchema.parse(parsed);
        return result;
    }
    catch (e) {
        throw new Error(`Failed to parse block: ${e.message}`);
    }
}
const TEMPLATE_VAR_REGEX = /\${{[\s]*([^}\s]+)[\s]*}}/g;
export function getTemplateVariables(templatedYaml) {
    const variables = new Set();
    const matches = templatedYaml.matchAll(TEMPLATE_VAR_REGEX);
    for (const match of matches) {
        variables.add(match[1]);
    }
    return Array.from(variables);
}
export function fillTemplateVariables(templatedYaml, data) {
    return templatedYaml.replace(TEMPLATE_VAR_REGEX, (match, variableName) => {
        // Inject data
        if (variableName in data) {
            return data[variableName];
        }
        // If variable doesn't exist, return the original expression
        return match;
    });
}
function flattenTemplateData(templateData) {
    const flattened = {};
    if (templateData.inputs) {
        for (const [key, value] of Object.entries(templateData.inputs)) {
            flattened[`inputs.${key}`] = value;
        }
    }
    if (templateData.secrets) {
        for (const [key, value] of Object.entries(templateData.secrets)) {
            flattened[`secrets.${key}`] = value;
        }
    }
    return flattened;
}
function secretToFQSNMap(secretNames, parentPackages) {
    const map = {};
    for (const secret of secretNames) {
        const parentSlugs = parentPackages.map(encodePackageSlug);
        const parts = [...parentSlugs, secret];
        const fqsn = parts.join("/");
        map[secret] = `\${{ secrets.${fqsn} }}`;
    }
    return map;
}
function extractFQSNMap(rawContent, parentPackages) {
    const templateVars = getTemplateVariables(rawContent);
    const secrets = templateVars
        .filter((v) => v.startsWith("secrets."))
        .map((v) => v.replace("secrets.", ""));
    return secretToFQSNMap(secrets, parentPackages);
}
export async function unrollAssistant(fullSlug, registry) {
    const assistantSlug = decodeFullSlug(fullSlug);
    // Request the content from the registry
    const rawContent = await registry.getContent(assistantSlug);
    return unrollAssistantFromContent(assistantSlug, rawContent, registry);
}
export async function unrollAssistantFromContent(assistantSlug, rawYaml, registry) {
    // Convert the raw YAML to unrolled config
    const templateData = {
        // no inputs to an assistant
        inputs: {},
        // at this stage, secrets are mapped to a (still templated) FQSN
        secrets: extractFQSNMap(rawYaml, [assistantSlug]),
        // Built-in variables
        continue: {},
    };
    // Render the template
    const templatedYaml = fillTemplateVariables(rawYaml, flattenTemplateData(templateData));
    // Parse string to Zod-validated YAML
    let parsedYaml = parseConfigYaml(templatedYaml);
    // Unroll blocks
    const unrolledAssistant = await unrollBlocks(parsedYaml, assistantSlug, registry);
    return unrolledAssistant;
}
export async function unrollBlocks(assistant, assistantFullSlug, registry) {
    const unrolledAssistant = {
        name: assistant.name,
        version: assistant.version,
    };
    const sections = [
        "models",
        "context",
        "data",
        "tools",
        "mcpServers",
        "prompts",
        "docs",
    ];
    // For each section, replace "uses/with" blocks with the real thing
    for (const section of sections) {
        if (assistant[section]) {
            const sectionBlocks = [];
            for (const unrolledBlock of assistant[section]) {
                // "uses/with" block
                if ("uses" in unrolledBlock) {
                    const blockConfigYaml = await resolveBlock(decodeFullSlug(unrolledBlock.uses), unrolledBlock.with, assistantFullSlug, registry);
                    const block = blockConfigYaml[section]?.[0];
                    if (block) {
                        sectionBlocks.push(mergeOverrides(block, unrolledBlock.override ?? {}));
                    }
                }
                else {
                    // Normal block
                    sectionBlocks.push(unrolledBlock);
                }
            }
            unrolledAssistant[section] = sectionBlocks;
        }
    }
    // Rules are a bit different because they're just strings, so handle separately
    if (assistant.rules) {
        const rules = [];
        for (const rule of assistant.rules) {
            if (typeof rule === "string") {
                rules.push(rule);
            }
            else {
                const blockConfigYaml = await resolveBlock(decodeFullSlug(rule.uses), rule.with, assistantFullSlug, registry);
                const block = blockConfigYaml.rules?.[0];
                if (block) {
                    rules.push(block);
                }
            }
        }
        unrolledAssistant.rules = rules;
    }
    return unrolledAssistant;
}
export async function resolveBlock(fullSlug, inputs, parentFullSlug, registry) {
    // Retrieve block raw yaml
    const rawYaml = await registry.getContent(fullSlug);
    // Render template variables
    const templateData = {
        inputs,
        secrets: extractFQSNMap(rawYaml, [parentFullSlug, fullSlug]),
        continue: {},
    };
    const templatedYaml = fillTemplateVariables(rawYaml, flattenTemplateData(templateData));
    const parsedYaml = parseBlock(templatedYaml);
    return parsedYaml;
}
export function mergeOverrides(block, overrides) {
    for (const key in overrides) {
        if (overrides.hasOwnProperty(key)) {
            block[key] = overrides[key];
        }
    }
    return block;
}
